# RabbitMQ 

1. Connect: 链接；生产者和RabbitMQ服务之间建立的TCP链接；
2. Channel: 信道; 一条链接可包含多条信道，不同信道之间通信互不干扰；考虑下多线程应用场景，每个线程对应一条信道，而不是对应一条链接，这样可以提高性能；
3. body: 消息主题，要传递的数据；
4. exchange: 交换器；负责把消息转发到对应的队列，交换器本身没有缓存消息的功能，消息是在队列中缓存，如果队列不存在则exchange直接丢弃；常用的有四个类型的交换器:direct, fanout, topic, headers。不同类型的交换器有不同的交换规则，交换器会根据交换规则把消息转发到对应的队列；
5. exchangeName: 交换器名称；发送消息时会附带交换器名称，根据交换器名称选择对应的交换器；
6. BandingKey: 绑定键；一个队列可以有一个到多个绑定键，通过绑定操作可以绑定交换器和队列，交换器会根据绑定键的名称找到对应的队列；
7. RoutingKey: 路由键，发送消息时，需要附带一条路由键，交换器会对路由键和绑定键进行匹配，如果匹配成功，则消息会转发到绑定键对应的队列中；

## 应用场景

### 1. 任务异步处理
将不需要同步处理的并且消耗时长的操作由消息队列通知消息接收方进行异步处理，提高了响应时间

### 2. 应用程序耦合
MQ相当于一个中介，生产方通过MQ与消费方通信。

## 工作原理
#### 1、Broker: 消息队列服务进程，此进程包括两个部分：Exchange和Queue;
#### 2、Exchange: 消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过滤；
#### 3、Queue: 消息队列，存储消息队列，消息到达队列并转发给指定的消费方；
#### 4、Producer: 消息生产者，将消息发送到MQ
#### 5、Consumer：消费者，接受MQ转发的消息

### 发送消息的过程：
#### 1. 生产者和Broker建立TCP链接
#### 2. 生产者和Broker建立通道
#### 3. 生产者通过通道消息发送给Broker，由Exchange将消息进行转发
#### 4. Exchange将消息转发到指定的Queue

### 接收消息
#### 1. 消费者和Broker建立TCP链接
#### 2. 消费者和Broker建立通道
#### 3. 消费者监听指定的Queue队列
#### 4. 当有消息到达Queue时Broker默认将消息推送给消费者
#### 5. 消费者接收到消息





## 工作模式:

1. 简单模式:
```
一个生产者P发送消息到队列Q，一个消费者C接受
```

2. 工作队列模式Work Queue:
```
一个生产者，多个消费者，每个消费者获取到的消息唯一，多个消费者只有一个队列

消息确认：
假设两个worker（A和B），假设某个worker（A）中的任务突然被kill，那么会丢失A处理的msg；如果不想丢失，那么RabbitMQ支持消息确认，消费者发送回一个消息确认，告知RabbitMQ可以自由删除它；
如果使用者宕机，（其通道已关闭，链接已关闭或TCP链接丢失）而没有发送确认，RabbitMQ将了解消息未完全处理，将处理，并将重新排队。如果同时有其他消费者在线，它将很快将其重新分发给另一个消费者。
RabbitMQ没有任何消息超时设置；消费者死亡时，RabbitMQ将重新传递信息，即使处理一条消息花费非常长的时间也没关系；
```
3. publish/subscribe 发布订阅模式
```
将消息传递给多个消费者；

1. 生产者是发送消息的用户应用程序；
2. 队列是存储消息的缓冲区
3. 使用者是接受消息的用户应用程序

RabbitMQ 消息传递模型中的核心思想是生产者从不将任何消息直接发送到队列；实际上，生产者甚至根本不知道是否将消息传递到任何队列；
实际上，生产者只能将消息发送到交换器。交换器一方面，接收来自生产者的消息，另一方面，将他们推入队列；
交换类型：direct, topic, headers, fanout

err = channel.ExchangeDeclare(
    "logs", // name
    "fanout", // type
    true, //durable
    false, //auto-deleted
    false, //internal
    false, //no-wait
    nil, //arguments
)

fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。
direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。

topic: #->匹配一个或多个词lazy.#可以匹配lazy.irs或者lazy.irs.cor;  *->只能匹配一个词lazy.* 可以匹配lazy.irs或lazy.cor


headers

```

```
channel.QueueDeclare(
    name string, //队列名称
    durable bool,  // 持久化 队列会存盘，在服务器重启的时候可以保证不丢失相关信息
    autoDelete bool, // 自动删除： 至少有一个消费者链接到这个队列，之后所有与这个队列链接的消费者全部断开时，才会删除？？？
    exclusive bool,  // 排他性 排他队列是基于连接可见，同一个连接的不同信道是可以同时访问同一个连接创建的排他队列；
                    //首次 是指如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；即使该队列是持久化，一旦连接关闭或者客户端退出，该排他队列都会自动被删除，这种队列适用于一个客户端同时发送和读取消息的应用场景
    noWait bool, 
    args Table,
)
```
